import re
import logging
import os

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def assess_complexity(sas_code, thresholds=None):
    """
    Analyze SAS code complexity to determine whether to use Simple or Complex conversion path.
    
    Parameters:
    - sas_code (str): The SAS code to analyze
    - thresholds (dict, optional): Custom thresholds for complexity metrics
    
    Returns:
    - str: "Simple" or "Complex" based on the complexity assessment
    """
    # Set default thresholds if not provided
    if thresholds is None:
        thresholds = {
            'SIMPLE_MAX_LINES': int(os.environ.get("SIMPLE_MAX_LINES", "20")),  # Lower threshold for example
            'SIMPLE_MAX_MACROS': int(os.environ.get("SIMPLE_MAX_MACROS", "2")),  # Lower threshold for example
            'SIMPLE_MAX_PROCS': int(os.environ.get("SIMPLE_MAX_PROCS", "3")),  # Lower threshold for example
            'SIMPLE_MAX_MACRO_CALLS': int(os.environ.get("SIMPLE_MAX_MACRO_CALLS", "2"))  # Lower threshold for example
        }
    
    # Calculate complexity metrics
    loc = sas_code.count('\n') + 1
    char_count = len(sas_code)
    
    # Count macro definitions using regex
    macro_defs = len(re.findall(r'^\s*%MACRO\s+\w+', sas_code, re.IGNORECASE | re.MULTILINE))
    
    # Count PROC statements
    proc_calls = len(re.findall(r'^\s*PROC\s+\w+', sas_code, re.IGNORECASE | re.MULTILINE))
    
    # Optional: Count Macro Calls
    macro_calls = len(re.findall(r'%\w+\(.*?\)', sas_code))
    
    # Optional: Detect Specific Complex PROCs
    has_complex_proc = bool(re.search(r'^\s*PROC\s+(FCMP|LUA|PROTO|OPTMODEL|IML)\b', 
                                      sas_code, 
                                      re.IGNORECASE | re.MULTILINE))
    
    # Optional: Detect Includes
    has_includes = bool(re.search(r'^\s*%INCLUDE\b', sas_code, re.IGNORECASE | re.MULTILINE))
    
    # Log the complexity metrics
    logger.info(f"SAS Complexity Metrics - Lines: {loc}, Chars: {char_count}, "
                f"Macros: {macro_defs}, PROCs: {proc_calls}, Macro Calls: {macro_calls}, "
                f"Has Complex PROCs: {has_complex_proc}, Has Includes: {has_includes}")
    
    # Classification Rule
    is_simple = (
        loc <= thresholds['SIMPLE_MAX_LINES'] and
        macro_defs <= thresholds['SIMPLE_MAX_MACROS'] and
        proc_calls <= thresholds['SIMPLE_MAX_PROCS'] and
        macro_calls <= thresholds['SIMPLE_MAX_MACRO_CALLS'] and
        not has_complex_proc and
        not has_includes
    )
    
    result = "Simple" if is_simple else "Complex"
    logger.info(f"Complexity assessment result: {result}")
    
    return result

def simple_conversion_path(sas_code):
    """
    Simple conversion path - converts SAS code to PySpark in a single LLM call.
    This is a simplified example implementation.
    """
    logger.info("Using Simple Conversion Path with direct single-call approach")
    
    # In a real implementation, this would make a single LLM call
    # For the example, we'll just return a placeholder
    pyspark_code = f"""
# PySpark conversion of SAS code via Simple Conversion Path
from pyspark.sql import SparkSession
from pyspark.sql.functions import col, lit

spark = SparkSession.builder.appName("SAS Conversion").getOrCreate()

# Simplified direct conversion of the {len(sas_code)} characters of SAS code
# This would be generated by a single LLM call in the real implementation
"""
    
    # Return the pyspark code and some dummy annotations
    return pyspark_code, [{"note": "Simple direct conversion"}], 4.5

def complex_conversion_path(sas_code):
    """
    Complex conversion path - uses multi-stage approach for SAS to PySpark conversion.
    This is a simplified example implementation.
    """
    logger.info("Using Complex Multi-Stage conversion path")
    
    # In a real implementation, this would:
    # 1. Split code into logical chunks
    # 2. Process each chunk with context tracking
    # 3. Handle refinement as needed
    
    # For the example, we'll just return a placeholder
    pyspark_code = f"""
# PySpark conversion of SAS code via Complex Multi-Stage Path
from pyspark.sql import SparkSession
from pyspark.sql.functions import col, lit, when, expr

spark = SparkSession.builder.appName("Complex SAS Conversion").getOrCreate()

# Multi-stage conversion of the {len(sas_code)} characters of SAS code
# This would be generated by multiple LLM calls in the real implementation
# Including structural analysis, conversion by chunk, and context tracking
"""
    
    # Return the pyspark code and some dummy annotations
    return pyspark_code, [{"note": "Complex multi-stage conversion"}], 4.0

def process_sas_code(sas_code, options=None):
    """
    Main function to process SAS code using the Adaptive Strategy.
    
    Parameters:
    - sas_code (str): The SAS code to convert
    - options (dict, optional): Conversion options
    
    Returns:
    - dict: Result with PySpark code and metadata
    """
    if options is None:
        options = {}
    
    # Use strategy override if provided
    strategy_override = options.get('strategy_override')
    
    if strategy_override in ['Simple Direct', 'Complex Multi-Stage']:
        strategy = strategy_override
        logger.info(f"Using strategy override: {strategy}")
    else:
        # Use Heuristic Complexity Analyzer
        complexity = assess_complexity(sas_code)
        
        if complexity == "Simple":
            strategy = "Simple Direct"
        else:  # complexity == "Complex"
            strategy = "Complex Multi-Stage"
        
        logger.info(f"Complexity assessed as {complexity}. Using {strategy} strategy")
    
    # Use appropriate conversion path based on strategy
    stats = {
        "strategy": strategy,
        "start_time": None,  # Would be set to time.time() in real implementation
        "end_time": None,    # Would be set after processing completes
        "llm_calls": 1 if strategy == "Simple Direct" else 4  # Sample value
    }
    
    if strategy == "Simple Direct":
        pyspark_code, annotations, confidence = simple_conversion_path(sas_code)
    else:  # "Complex Multi-Stage"
        pyspark_code, annotations, confidence = complex_conversion_path(sas_code)
    
    # Return the results
    return {
        "pyspark_code": pyspark_code,
        "annotations": annotations,
        "confidence": confidence,
        "stats": stats,
        "strategy_used": strategy
    }

# Example usage
if __name__ == "__main__":
    # Example 1: Simple SAS code
    simple_sas = """
    DATA work.output;
        SET raw.input;
        new_var = old_var * 2;
        IF category = 'A' THEN output;
    RUN;
    
    PROC PRINT data=work.output;
    RUN;
    """
    
    # Example 2: Complex SAS code with macros and multiple PROCs
    complex_sas = """
    %MACRO process_data(indata, filter);
        DATA work.temp;
            SET &indata;
            WHERE category = "&filter";
            date_formatted = PUT(date, YYMMDD10.);
        RUN;
        
        PROC SORT data=work.temp;
            BY id;
        RUN;
        
        PROC SUMMARY data=work.temp;
            CLASS region;
            VAR sales;
            OUTPUT OUT=work.summary SUM=total_sales;
        RUN;
    %MEND;
    
    %MACRO another_macro(param1);
        /* Another macro */
        %PUT &param1;
    %MEND;
    
    %MACRO complex_macro(date, region);
        /* Complex macro with nested logic */
        DATA work.step1;
            SET raw.data;
            WHERE date = "&date";
        RUN;
        
        PROC SQL;
            CREATE TABLE work.step2 AS
            SELECT *
            FROM work.step1
            WHERE region = "&region";
        QUIT;
        
        %process_data(work.step2, A);
    %MEND;
    
    %process_data(raw.sales, B);
    %complex_macro(2023-01-01, EAST);
    
    PROC MEANS data=work.summary;
    RUN;
    
    PROC TABULATE data=work.summary;
        CLASS region;
        VAR total_sales;
        TABLE region, total_sales;
    RUN;
    """
    
    # Process both examples
    simple_result = process_sas_code(simple_sas)
    complex_result = process_sas_code(complex_sas)
    
    # Display results
    print("\n==== Simple SAS Result ====")
    print(f"Strategy: {simple_result['strategy_used']}")
    print(f"Confidence: {simple_result['confidence']}")
    print(f"LLM Calls: {simple_result['stats']['llm_calls']}")
    print("PySpark Code Preview:")
    print("\n".join(simple_result['pyspark_code'].split("\n")[:10]))
    
    print("\n==== Complex SAS Result ====")
    print(f"Strategy: {complex_result['strategy_used']}")
    print(f"Confidence: {complex_result['confidence']}")
    print(f"LLM Calls: {complex_result['stats']['llm_calls']}")
    print("PySpark Code Preview:")
    print("\n".join(complex_result['pyspark_code'].split("\n")[:10])) 